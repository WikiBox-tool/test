<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>スマホ対応テトリス</title>
  <style>
    body { margin: 0; padding: 0; background: #222; color: #fff; font-family: sans-serif; }
    canvas { background: #eee; display: block; margin: 20px auto; }
    .controls {
      text-align: center;
      margin: 10px auto;
    }
    .button {
      padding: 12px 20px;
      font-size: 16px;
      margin: 5px;
      border: none;
      border-radius: 4px;
      background-color: #3498db;
      color: white;
      touch-action: manipulation;
    }
    .button:active {
      background-color: #2980b9;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="240" height="400"></canvas>
  <div class="controls">
    <button class="button" id="btnLeft">←</button>
    <button class="button" id="btnRotate">⟳</button>
    <button class="button" id="btnRight">→</button>
    <button class="button" id="btnDown">↓</button>
  </div>

  <script>
    // 初期設定
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // ゲーム設定
    const COLS = 10;
    const ROWS = 20;
    const BLOCK_SIZE = 20;
    canvas.width = COLS * BLOCK_SIZE;
    canvas.height = ROWS * BLOCK_SIZE;

    // ゲームの初期化
    let board = [];
    for (let r = 0; r < ROWS; r++) {
      board[r] = [];
      for (let c = 0; c < COLS; c++) {
        board[r][c] = 0;
      }
    }

    // テトリスの各ピース
    const pieces = [
      { shape: [[1,1,1,1]], color: 'cyan' },      // I
      { shape: [[1,1],[1,1]], color: 'yellow' },    // O
      { shape: [[0,1,0],[1,1,1]], color: 'purple' },  // T
      { shape: [[1,0,0],[1,1,1]], color: 'orange' },  // L
      { shape: [[0,0,1],[1,1,1]], color: 'blue' },    // J
      { shape: [[1,1,0],[0,1,1]], color: 'green' },   // S
      { shape: [[0,1,1],[1,1,0]], color: 'red' }      // Z
    ];

    // ピースを生成
    function randomPiece() {
      const p = pieces[Math.floor(Math.random() * pieces.length)];
      // ピースは中央上部から
      return { shape: p.shape, color: p.color, x: Math.floor((COLS - p.shape[0].length) / 2), y: 0 };
    }

    let currentPiece = randomPiece();
    let dropStart = Date.now();
    let gameOver = false;

    // 描画関数
    function drawBlock(x, y, color) {
      ctx.fillStyle = color;
      ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
      ctx.strokeStyle = '#fff';
      ctx.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
    }

    // ピースを描画
    function drawPiece(piece) {
      for (let r = 0; r < piece.shape.length; r++) {
        for (let c = 0; c < piece.shape[r].length; c++) {
          if (piece.shape[r][c]) {
            drawBlock(piece.x + c, piece.y + r, piece.color);
          }
        }
      }
    }

    // ブロックを再描画
    function undraw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      // 固定されたブロック
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          if (board[r][c]) {
            drawBlock(c, r, board[r][c]);
          }
        }
      }
    }

    // 衝突
    function collision(piece, offsetX, offsetY) {
      for (let r = 0; r < piece.shape.length; r++) {
        for (let c = 0; c < piece.shape[r].length; c++) {
          if (piece.shape[r][c]) {
            let newX = piece.x + c + offsetX;
            let newY = piece.y + r + offsetY;
            if (newX < 0 || newX >= COLS || newY >= ROWS) {
              return true;
            }
            if (newY >= 0 && board[newY][newX]) {
              return true;
            }
          }
        }
      }
      return false;
    }

    // ピースを固定
    function freeze() {
      for (let r = 0; r < currentPiece.shape.length; r++) {
        for (let c = 0; c < currentPiece.shape[r].length; c++) {
          if (currentPiece.shape[r][c]) {
            if(currentPiece.y + r < 0) {
              gameOver = true;
              alert("Game Over");
              return;
            }
            board[currentPiece.y + r][currentPiece.x + c] = currentPiece.color;
          }
        }
      }
      // 完全な削除処理
      for(let r = 0; r < ROWS; r++){
        let isRowFull = true;
        for(let c = 0; c < COLS; c++){
          if(!board[r][c]) {
            isRowFull = false;
            break;
          }
        }
        if(isRowFull){
          for(let y = r; y > 0; y--){
            for(let c = 0; c < COLS; c++){
              board[y][c] = board[y-1][c];
            }
          }
          for(let c = 0; c < COLS; c++){
            board[0][c] = 0;
          }
        }
      }
      currentPiece = randomPiece();
    }

    // 回転処理
    function rotate(piece) {
      let newShape = [];
      for (let c = 0; c < piece.shape[0].length; c++) {
        let newRow = [];
        for (let r = piece.shape.length - 1; r >= 0; r--) {
          newRow.push(piece.shape[r][c]);
        }
        newShape.push(newRow);
      }
      return newShape;
    }

    // 1段落下
    function drop() {
      if (!collision(currentPiece, 0, 1)) {
        currentPiece.y++;
      } else {
        freeze();
      }
      undraw();
      drawPiece(currentPiece);
    }

    // ゲームループ
    function update() {
      let now = Date.now();
      let delta = now - dropStart;
      if (delta > 1000) { // 1秒ごとに自動で落下
        drop();
        dropStart = Date.now();
      }
      if (!gameOver) {
        requestAnimationFrame(update);
      }
    }

    // ボタンタッチイベント
    document.getElementById('btnLeft').addEventListener('touchstart', function(e) {
      e.preventDefault();
      if (!collision(currentPiece, -1, 0)) {
        currentPiece.x--;
      }
      undraw();
      drawPiece(currentPiece);
    });

    document.getElementById('btnRight').addEventListener('touchstart', function(e) {
      e.preventDefault();
      if (!collision(currentPiece, 1, 0)) {
        currentPiece.x++;
      }
      undraw();
      drawPiece(currentPiece);
    });

    document.getElementById('btnDown').addEventListener('touchstart', function(e) {
      e.preventDefault();
      drop();
    });

    document.getElementById('btnRotate').addEventListener('touchstart', function(e) {
      e.preventDefault();
      let rotated = rotate(currentPiece);
      let backup = currentPiece.shape;
      currentPiece.shape = rotated;
      if (collision(currentPiece, 0, 0)) {
        currentPiece.shape = backup;
      }
      undraw();
      drawPiece(currentPiece);
    });

    // スマホの場合
    document.getElementById('btnLeft').addEventListener('click', function(e) {
      e.preventDefault();
      if (!collision(currentPiece, -1, 0)) {
        currentPiece.x--;
      }
      undraw();
      drawPiece(currentPiece);
    });
    document.getElementById('btnRight').addEventListener('click', function(e) {
      e.preventDefault();
      if (!collision(currentPiece, 1, 0)) {
        currentPiece.x++;
      }
      undraw();
      drawPiece(currentPiece);
    });
    document.getElementById('btnDown').addEventListener('click', function(e) {
      e.preventDefault();
      drop();
    });
    document.getElementById('btnRotate').addEventListener('click', function(e) {
      e.preventDefault();
      let rotated = rotate(currentPiece);
      let backup = currentPiece.shape;
      currentPiece.shape = rotated;
      if (collision(currentPiece, 0, 0)) {
        currentPiece.shape = backup;
      }
      undraw();
      drawPiece(currentPiece);
    });

    // ゲーム開始
    update();
  </script>
</body>
</html>
